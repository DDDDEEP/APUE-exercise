## 8.1 如果在子进程中用 exit 调用代替 _exit 调用，那么可能会使标准输出关闭，使 printf 返回 -1，事实是否如此？如果不是，怎么处理才能得到类似结果？

替换后子进程退出后会刷新子缓冲区，但实际上并不会关闭流

如果要模拟关闭标准输出，可在子进程退出前调用 `fclose(stdout);`

## 8.2 调用 vfork 后，子进程会运行在父进程的地址空间中，如果不是在 main 中而是在另一个函数中调用 vfork，此后子进程又从该函数返回，将会发生什么？

此时子进程会根据栈帧正常返回并继续工作，但当父进程再次工作时，父进程会从调用函数对应的栈帧继续工作，但该函数栈帧已经被子进程返回并销毁，之后程序的行为属于不确定行为

类似的，`vfork` 的子进程退出时不应该使用 `return`，因为这样会使 main 函数返回，而当转至父进程工作时，main 的栈帧被返回，程序就会出错

## 8.3 把 wait 换成 waitid，不调用 pr_exit，而从 siginfo 结构中确定等价的信息

## 8.4 对一个“子进程等待父进程输出，然后子进程再输出”的程序，只调用一次时输出是正确的，但调用多次时输出未必正确，这是为什么？如何更正？若子进程先输出，还会出现问题吗？

因为当子进程等待例程返回后，父进程可能会终止，然后 shell 开始执行下一个程序，这个行为会与子进程的输出行为产生竞争

要更正这个错误，就让父进程输出后，进入等待子进程返回的状态

若子进程先输出，则不会出现该问题，因为只有父进程终止后，才可开始下一个程序

## 8.5 若在调用 execl、指定 pathname 的程序中，改为调用 execlp、指定 filename 的程序，那么如果目录前缀为对应的 pathname，则允许程序时，exec 后的程序参数是否改变？

没有改变，因为 `execlp` 在结束后调用 `execve`，而传入 filename 时，与调用 `execl`、传入 pathname 的结果是一样的

## 8.6 编写程序创建一个僵尸进程，并调用 system 执行 ps 命令验证