## 7.1 在 Intel x86 系统上，执行一个输出“hello, world”的程序而不调用 exit 和 return 的程序，程序返回代码为什么是 13

`printf` 的返回值变成了 main 函数的返回值

## 7.2 终止处理程序的 `printf` 什么时候才会真正输出？

当程序处于交互运行方式时，标准输出处于行缓冲方式，所以当输出换行符时才会真正输出

如果标准输出被定向到一个文件，此时其处于全缓冲方式，则当标准 I/O 清理操作执行时，结果才会真正输出

## 7.3 除参数传递和全局变量之外，是否还有方法可将 main 的参数 argc 和 argv 传递给它所调用的其它函数？

通常没有

## 7.4 在有些 UNIX 系统的实现中，执行程序时访问不到其它数据段的 0 单元，为什么要这么安排？

如果 C 程序解引用一个空指针，执行程序将会终止，可使用该方法终止程序

## 7.5 使用 typedef 为终止处理程序定义一个新类型 Exitfunc，使用该类型修改 atexit 的原型

```c
typedef void Exitfunc(void);
int atexit(Exitfunc *func);
```

## 7.6 如果用 calloc 分配一个 long 类型数组，数组的初始值是否为 0？如果用 calloc 分配一个指针数组，数组的初始值是否为空指针？

虽然将内存空间初始化为 0，但并不保证 0 值就是浮点 0 或空指针

## 7.7 为什么 size 命令不给出堆和栈的大小

只有 `exec` 执行一个程序时，才会分配堆和栈

## 7.8 为什么文件大小不等于正文段和数据段之和？

因为可执行文件包含了调试的符号表信息，使用 `strip` 命令可以删除这些信息

## 7.9 为什么阻止使用共享库后执行文件大小的变化会这么大？

因为没有使用共享库后，执行文件的大部分被标准 I/O 库占用

## 7.10 不要将一个指针返回给一个自动变量，下面程序是否正确？

```c
int f1(int val)
{
    int num = 0;
    int *ptr = &num;
    if (val == 0)
    {
        int val;
        val = 5;
        ptr = &val; // 引起问题
    }
    return (*ptr + 1);
}
```

